---
title: "Fixed Human tumor samples"
output: html_notebook
---

The goal of this project is to analyze single cell data from a paper. We'll use nine fixed tumor samples from de Faria et al (https://www.nature.com/articles/s41467-022-30626-8). The data is available in GEO (GSE186144). 

### Loading libraries

```{r, include=FALSE}
library(here)
library(Seurat)
library(org.Hs.eg.db)
library(KEGGREST)
library(clusterProfiler)
library(patchwork)
library(tidyverse)
```

### Reading data

KK22-H-225	Human ETMR tumor C19MC amplified 
KK22-H-226	Human ETMR tumor C19MC amplified 
KK22-H-227	Dicer mutation
KK23-H-507	Human ETMR tumor C19MC amplified 
KK23-H-508	Human ETMR tumor C19MC amplified 
KK23-H-509	Human ETMR tumor C19MC amplified 
KK23-H-510	Human ETMR tumor C19MC amplified 
KK23-H-511	Human ETMR tumor C19MC amplified 
KK23-H-512	Human ETMR tumor C19MC amplified 


```{r, warning=FALSE, eval=FALSE}
#I did a lot of things in bash to get the extracted files from GSE186144_RAW into individual folders with the names that Seurat expects. The final sh script may not work as intented because it was created afterwards. The main thing that might fail is deleting the prefixes. Original file (processed) from: https://www.ncbi.nlm.nih.gov/Traces/study/?acc=PRJNA1072016&o=acc_s%3Aa&s=SRR27831379,SRR27831380,SRR27831381,SRR27831382,SRR27831383,SRR27831384,SRR27831385,SRR27831386,SRR27831387

ids <- c(
  "GSM8058157_KK22-H-225",
"GSM8058158_KK22-H-226", 
"GSM8058159_KK22-H-227",
"GSM8058160_KK23-H-507",
"GSM8058161_KK23-H-508",
"GSM8058162_KK23-H-509",
"GSM8058163_KK23-H-510",
"GSM8058164_KK23-H-511",
"GSM8058165_KK23-H-512"
)



path <- sapply(ids, function(x) paste0(here::here(), "/de Faria/snRNA/data/GSE254819_RAW/", x, "/"))

read_data <- Read10X(path)

snrna.data <- CreateSeuratObject(counts = read_data, project = "snfixedtumor", min.cells = 3, min.features = 200)

snrna.data


sample_info <- df <- tribble(
  ~orig.ident,      ~Sample_ID,   ~Tumor_Type,
  "GSM8058157", "KK22-H-225", "C19MC",
  "GSM8058158", "KK22-H-226", "C19MC",
  "GSM8058159", "KK22-H-227", "Dicer",
  "GSM8058160", "KK23-H-507", "C19MC",
  "GSM8058161", "KK23-H-508", "C19MC",
  "GSM8058162", "KK23-H-509", "C19MC",
  "GSM8058163", "KK23-H-510", "C19MC",
  "GSM8058164", "KK23-H-511", "C19MC",
  "GSM8058165", "KK23-H-512", "C19MC")


snrna.data@meta.data <- snrna.data@meta.data %>%
  rownames_to_column(var = "rownames") %>%
  right_join(sample_info, by = "orig.ident") %>%
  column_to_rownames(var = "rownames")


snrna.data[["RNA"]] <- split(snrna.data[["RNA"]], f = snrna.data$Tumor_Type)
snrna.data



```

### QC metrics

```{r, warning=FALSE, eval=FALSE}

# The [[ operator can add columns to object metadata. This is a great place to stash QC stats
snrna.data[["percent.mt"]] <- PercentageFeatureSet(snrna.data, pattern = "^MT-")

# Visualize QC metrics as a violin plot
#This is better
VlnPlot(snrna.data, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)



```

### Filtering the data

```{r, eval=FALSE}
#The threshold is determined based on the plots. Usual mitochondrial threshold for humans is around 10%, but in this case I see there's a lot of cells over that, so I'll try with a 20% and see after clustering if i need to make it more strict

snrna.data <- subset(snrna.data, subset = nFeature_RNA > 200 & nCount_RNA < 40000 & percent.mt < 25)
VlnPlot(snrna.data, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)

```

### Normalizing the data

```{r, eval=FALSE}

#This global scaling method assumes there's an equal number of RNA molecules in all the cells. There's other ways to mormalize data without assuming this (https://genomebiology.biomedcentral.com/articles/10.1186/s13059-021-02584-9 and https://satijalab.org/seurat/articles/sctransform_vignette). This code shows the default settings used when the function is called:

# snrna.data <- NormalizeData(snrna.data, normalization.method = "LogNormalize", scale.factor = 10000)

snrna.data <- NormalizeData(snrna.data)

```



### Identifying highly variable features (feature selection)

```{r,eval=FALSE}
#The method used to identify features as highly variable is described hede: https://www.sciencedirect.com/science/article/pii/S0092867419305598?via%3Dihub

snrna.data <- FindVariableFeatures(snrna.data, selection.method = "vst")

top10 <- head(VariableFeatures(snrna.data), 10)

# A warning comes up because the
variance_plot <- LabelPoints(plot = VariableFeaturePlot(snrna.data), points = top10, repel = TRUE, xnudge = 0, ynudge = 0)

variance_plot

# 
# snrna.data[["RNA"]]$counts[setdiff(Features(snrna.data), VariableFeatures(snrna.data)),]

```


### Linear dimensional reduction

```{r, eval=FALSE}

#You should explore different approaches to choose how many dimensions to use. You can explore the PCs and look for relevant sources of heterogeneity (can be used in conjuction with GSEA), or you can use the elbow plot or a heuristic??. In any case, err on the side of more dimensions and experiment.

snrna.data <- ScaleData(snrna.data, verbose = FALSE)

# snrna.data <- RunPCA(snrna.data, features = VariableFeatures(object = snrna.data), verbose = FALSE)

snrna.data <- RunPCA(snrna.data, verbose = FALSE)

DimPlot(snrna.data, reduction = "pca") + NoLegend()

ElbowPlot(snrna.data)

DimHeatmap(snrna.data, dims = 1:10, cells = 500, balanced = TRUE)

```

### Clustering the cells

```{r linear, eval=FALSE}


#Seurat uses a graph-based approach that embeds cells into a graph structure, drawing edges between cells with similar feature expression patterns in order to partition the graph into highly interconnected "quasi-cliques"/"communities"

#Edge weights defined by Jaccard distance (shared overlap in local neighborhood) with FindNeighbors() using the number of PCs that was decided in th eprevious step
set.seed(2025)

snrna.data <- FindNeighbors(snrna.data, dims = 1:20)

#To cluster the cells Seurat uses the Louvain algorithm by default or SLM (http://dx.doi.org/10.1088/1742-5468/2008/10/P10008) to iteratively group cells together by optimizing the standard modularity function
#FindClusters() does this procedure and includes a parameter that sets the "granularity" of the clusters (larger values means more clusters; for 3k cells 0.4-1.2 is usually good and the value increases for larger datasets)

snrna.data <- FindClusters(snrna.data, resolution = 0.5)


#You can see the clusters with Idents()


# head(Idents(snrna.data), 5)

```

```{r non_linear, eval=FALSE}
set.seed(2025)
#UMAP and tSNE are used to place similar cells together in low-dimensional space. This means that cells that were grouped in the same clusters in the previous step should colocalize in these plots.

#CAUTION!!! These representations can't capture more global relationships between cells and should not be used as the sole basis for drawing biological conclusions

snrna.data <- RunUMAP(snrna.data, dims = 1:20)  

DimPlot(snrna.data, reduction = "umap", label = TRUE)  + NoLegend()
DimPlot(snrna.data, reduction = "umap", label = TRUE, group.by = "orig.ident") + NoLegend()



```

### Integration

```{r}

#takes 14m 14s!!!
# snrna.data <- IntegrateLayers(
#   object = snrna.data, method = CCAIntegration,
#   orig.reduction = "pca", new.reduction = "integrated.cca",
#   verbose = FALSE
# )
# 
# saveRDS(snrna.data, file = "snrna.data")

snrna.data <- readRDS("snrna.data")

snrna.data <- FindNeighbors(snrna.data, reduction = "integrated.cca", dims = 1:20)

snrna.data <- FindClusters(snrna.data, resolution = 0.5, cluster.name = "cca_clusters")

snrna.data <- RunUMAP(snrna.data, reduction = "integrated.cca", dims = 1:20, reduction.name = "umap.cca")

p1 <- DimPlot(
  snrna.data,
  reduction = "umap.cca",
  group.by = c("orig.ident", "Tumor_Type", "cca_clusters"),
  combine = FALSE, label.size = 2, label = TRUE
) 

p1_all <- p1[[1]] + NoLegend() + ggtitle("Sample") +
  p1[[2]] + NoLegend() + ggtitle("Tumor_Type") +
  p1[[3]] + ggtitle("cca_clusters") + NoLegend()

ggsave(p1_all, filename = paste0(here::here(), "/de Faria/snRNA/plots/snRNA_integration_umap.png"), width = 10, height = 4)

snrna.data <- JoinLayers(snrna.data)
snrna.data

```


### Finding DE features (cluster biomarkers)

```{r, warning=FALSE}

#Seurat ids positive and negative markers of single clusters compared to all other cells. FindAllMarkers() automated the process for all clusters, but you can choose groups of clusters and compare them to each other or other cells (FindMarkers()).
#Pretty sure under the hood there's Wilcoxon and AUCROC (Seurat asked to install the presto package to make these operations faster (https://github.com/immunogenomics/presto))

#There's a lot of options for DE analysis (https://satijalab.org/seurat/articles/de_vignette)

set.seed(2025)

snrna.data.markers <- FindAllMarkers(snrna.data, min.pct = 0.25, min.diff.pct = 0.25, only.pos = FALSE)


# top50 <- snrna.data.markers %>% group_by(cluster) %>% top_n(n = 50, wt = avg_log2FC)

# de_per_cluster <- setNames(sapply(seq(0,15), function(x) snrna.data.markers %>% filter(cluster==x) %>% select(gene)), paste0("Cluster",seq(0,15))) 

gene_ref <- readxl::read_excel(paste0(here::here(),"/de Faria/snRNA/data/paper_info.xlsx")) 



in_ref <- snrna.data.markers[snrna.data.markers$gene %in% gene_ref$marker,]


in_ref_summary <- in_ref %>% left_join(gene_ref, by = c("gene"="marker")) %>%
  select(gene, cluster, avg_log2FC, pct.1, pct.2, p_val_adj, cell_type) %>%
  arrange(cluster, desc(avg_log2FC))


#We need to load the genes that weren't ETMR markers to id the other clusters

```

